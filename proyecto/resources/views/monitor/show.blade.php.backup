{{-- resources/views/monitor/show.blade.php --}}
@extends('layouts.dashboard')

@section('title', 'Detalles del Host: ' . $host->hostname)

@section('css')
    {{-- Terminal CSS --}}
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" />
    <style>
        /* Estilos para terminal */
        #terminal-container {
            width: 100%;
            height: 450px;
            background-color: #300a24 !important; /* Color de fondo Ubuntu forzado */
            border-radius: 8px;
            padding: 0;
            display: none;
            overflow: hidden;
            position: relative;
            font-family: 'Ubuntu Mono', 'DejaVu Sans Mono', 'Courier New', monospace;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: 1px solid #2b0821;
            transition: all 0.3s ease;
            z-index: 1000; /* Asegurar que esté por encima de otros elementos */
        }
        
        /* Estilos para el contenedor interno del terminal */
        #terminal-basic {
            background-color: #300a24 !important; /* Forzar color de fondo */
            position: absolute;
            top: 36px; /* Altura de la barra de título */
            bottom: 22px; /* Altura de la barra de estado */
            left: 0;
            right: 0;
            overflow: hidden;
        }
        
        /* Barra de título estilo Ubuntu */
        .terminal-titlebar {
            height: 36px;
            background-color: #3e0d35 !important; /* Forzar color de barra de título */
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: flex;
            align-items: center;
            padding: 0 12px;
            color: white;
            font-family: 'Ubuntu', sans-serif;
            font-size: 14px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            z-index: 1001; /* Asegurar que esté por encima del terminal */
        }
        
        .terminal-titlebar-buttons {
            display: flex;
            margin-right: 15px;
        }
        
        .terminal-button {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .terminal-button:hover {
            transform: scale(1.1);
        }
        
        .terminal-button-close {
            background-color: #ff5f57;
        }
        
        .terminal-button-minimize {
            background-color: #ffbd2e;
        }
        
        .terminal-button-maximize {
            background-color: #28ca41;
        }
        
        /* Estilos para modal y pantalla completa */
        .terminal-fullscreen {
            position: fixed !important;
            top: 10px !important;
            left: 10px !important;
            width: calc(100vw - 20px) !important;
            height: calc(100vh - 20px) !important;
            z-index: 9999 !important;
            border-radius: 8px !important;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.6) !important;
        }
        
        #terminal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 9990;
            display: none;
            backdrop-filter: blur(3px);
        }
        
        #terminal-exit-fullscreen {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            z-index: 10000;
            display: none;
        }
        
        /* Mejorar scrollbar para terminal */
        .xterm-viewport::-webkit-scrollbar {
            width: 10px;
        }
        
        .xterm-viewport::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .xterm-viewport::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(0, 0, 0, 0.2);
        }
        
        .xterm-viewport::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.4);
        }
        
        /* Ajustes para el scroll del terminal */
        .xterm-viewport {
            overflow-y: auto !important;
            scrollbar-width: thin !important;
            scroll-behavior: smooth !important;
        }
        
        /* Asegurar que xterm ocupa todo el espacio disponible */
        .xterm {
            height: calc(100% - 36px) !important; /* Resta la altura de la barra de título */
            padding: 2px;
            background-color: #300a24 !important; /* Forzar color de fondo para xterm */
        }
        
        /* Forzar color de fondo para las capas internas de xterm */
        .xterm-screen, .xterm-viewport {
            background-color: #300a24 !important;
        }
        
        /* Animación para carga del terminal */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #terminal-container.show {
            animation: fadeIn 0.3s ease forwards;
        }
        
        /* Barra de estado del terminal */
        .terminal-statusbar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 22px;
            background-color: #32123a !important; /* Forzar color */
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 11px;
            color: #ccc;
            border-top: 1px solid #2b0821;
            z-index: 1001; /* Asegurar que esté por encima del terminal */
        }
        
        /* Indicador de conexión */
        .connection-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .connection-active {
            background-color: #4CAF50;
            box-shadow: 0 0 5px #4CAF50;
        }
        
        .connection-inactive {
            background-color: #F44336;
            box-shadow: 0 0 5px #F44336;
        }
        
        /* Estilo para el cursor */
        .terminal-cursor {
            background-color: #fff !important;
            border-color: #fff !important;
        }
        
        /* Mejor contraste para el texto */
        .xterm-text-layer {
            opacity: 1 !important;
        }
        
        /* Fix para pantalla completa en dispositivos móviles */
        @media (max-width: 768px) {
            .terminal-fullscreen {
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                border-radius: 0 !important;
            }
        }

        .connection-warning {
            background-color: #FF9800;
            box-shadow: 0 0 5px #FF9800;
        }
    </style>
@endsection

@section('content')
{{-- Meta CSRF para AJAX --}}
<meta name="csrf-token" content="{{ csrf_token() }}">

{{-- Scripts WebSockets (cargamos independientemente de app.js) --}}
<script src="https://cdn.jsdelivr.net/npm/pusher-js@8.3.0/dist/web/pusher.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/laravel-echo@1.15.3/dist/echo.iife.js"></script>

<script>
// Mostrar instrucciones para iniciar manualmente Reverb de forma correcta
function showReverbInstructions() {
    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket Reverb no está activo.\x1B[0m\r\n');
    terminal.write('\r\n\x1B[1;36mSigue estas instrucciones para iniciar Reverb correctamente:\x1B[0m\r\n\r\n');
    terminal.write('\x1B[1;32m1. Abre una nueva ventana CMD o PowerShell como administrador\x1B[0m\r\n');
    terminal.write('\x1B[1;32m2. Navega EXACTAMENTE al directorio del proyecto:\x1B[0m\r\n');
    terminal.write('\x1B[1;37m   cd "X:\\DANI ESCRITORIO Y DESCARGAS\\DANI ESCRITORIO\\proyectoDA\\proyecto"\x1B[0m\r\n\r\n');
    terminal.write('\x1B[1;32m3. Ejecuta el comando para iniciar Reverb:\x1B[0m\r\n');
    terminal.write('\x1B[1;37m   php artisan reverb:start\x1B[0m\r\n\r\n');
    terminal.write('\x1B[1;32m4. Deja esa ventana abierta y recarga esta página\x1B[0m\r\n\r\n');
    terminal.write('\r\n\x1B[1;36mLos comandos no funcionarán hasta que el servidor WebSocket esté activo.\x1B[0m\r\n');
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
                    _token: '{{ csrf_token() }}'
                },
                success: function(response) {
                    console.log('Comando enviado exitosamente via endpoint WebSocket');
                },
                error: function(xhr, status, error) {
                    console.error('Error al enviar comando via endpoint WebSocket:', error);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo enviar el comando\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;33m⚠ El servidor WebSocket debe estar corriendo para que funcione el terminal\x1B[0m\r\n');
                    showReverbInstructions();
                }
            });
        }
    } catch (error) {
        console.error('Error al enviar comando por WebSockets:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
    }
}

// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Timeout para conexiones
            activityTimeout: 10000,
            pongTimeout: 5000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo:', error);
        window.echoConnectionFailed = true;
    }
});

// Función para configurar la conexión WebSocket
function setupWebSocketConnection(sessionId) {
    console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
    
    // Si Echo no está disponible o la conexión falló
    if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
        console.warn('Laravel Echo no está disponible - el terminal no funcionará sin WebSockets');
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
    
    try {
        // Verificar estado actual de la conexión pusher
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Si ya está en estado conectado
            if (window.Echo.connector.pusher.connection.state === 'connected') {
                subscribeToChannel();
                return true;
            }
            
            // Si está en otro estado, esperar el evento connected
            window.Echo.connector.pusher.connection.bind('connected', function() {
                console.log('Conexión WebSocket establecida tardíamente');
                subscribeToChannel();
            });
            
            // Después de un breve tiempo, verificar de nuevo
            setTimeout(function() {
                if (window.Echo.connector.pusher.connection.state !== 'connected') {
                    console.warn('Conexión WebSocket fallida');
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo establecer la conexión WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }, 5000);
        } else {
            console.warn('Configuración de Echo incompleta');
            terminal.write('\r\n\x1B[1;31m✗ Error: Configuración WebSocket incompleta\x1B[0m\r\n');
            showReverbInstructions();
            return false;
        }
        
        function subscribeToChannel() {
            // Primero intentar con un canal privado
            try {
                window.Echo.private(`terminal.${sessionId}`)
                    .listen('TerminalOutputReceived', processWebSocketResponse);
                    
                console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
            } catch (error) {
                console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                
                // Si falla, intentar con un canal público
                try {
                    window.Echo.channel(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                } catch (innerError) {
                    console.error('Error al suscribirse a canal público:', innerError);
                    terminal.write('\r\n\x1B[1;31m✗ Error: No se pudo suscribir al canal WebSocket\x1B[0m\r\n');
                    showReverbInstructions();
                    return false;
                }
            }
            
            updateConnectionStatus(true, `Conectado con WebSockets`);
            return true;
        }
        
        return true;
    } catch (error) {
        console.error('Error al configurar WebSocket:', error);
        terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
        showReverbInstructions();
        return false;
    }
}

// Ejecutar comando en el servidor usando exclusivamente WebSockets
function executeCommand(command, element) {
    // Verificación para detectar si hay un mensaje inicial
    if (command === 'cd ~') {
        // Comprobar si los WebSockets fallaron después de intentar la conexión
        setTimeout(function() {
            if (window.echoConnectionFailed) {
                terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
                showReverbInstructions();
            } else {
                terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
            }
        }, 2000);
    }

    // Esconder elemento de historial si es necesario
    if (element) {
        $(element).hide();
    }

    // Mostrar comando en terminal con el formato correcto
    const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
    terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

    // Si no hay conexión activa, mostrar error
    if (!isConnected || !sessionId) {
        terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
        return;
    }

    // Si los WebSockets no están funcionando, mostrar error
    if (window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
        terminal.write('\r\n\x1B[1;31m✗ Error: El servidor WebSocket no está disponible\x1B[0m\r\n');
        showReverbInstructions();
        return;
    }

    // Usar WebSockets para ejecutar el comando
    try {
        console.log('Ejecutando comando via WebSockets:', command);
        
        // Intentamos con private channel
        try {
            window.Echo.private('terminal.' + sessionId)
                .whisper('command', {
                    command: command
                });
            console.log('Comando enviado via whisper');
        } catch (error) {
            console.error('Error al enviar comando por whisper:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al enviar comando: ' + error.message + '\x1B[0m\r\n');
            
            // Si falla, intentamos a través del endpoint HTTP para WebSockets
            $.ajax({
                url: '/api/websocket/command',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    command: command,
{{-- resources/views/monitor/show.blade.php --}}
@extends('layouts.dashboard')

@section('title', 'Detalles del Host: ' . $host->hostname)

@section('css')
    {{-- Terminal CSS --}}
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" />
    <style>
        /* Estilos para terminal */
        #terminal-container {
            width: 100%;
            height: 450px;
            background-color: #300a24 !important; /* Color de fondo Ubuntu forzado */
            border-radius: 8px;
            padding: 0;
            display: none;
            overflow: hidden;
            position: relative;
            font-family: 'Ubuntu Mono', 'DejaVu Sans Mono', 'Courier New', monospace;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: 1px solid #2b0821;
            transition: all 0.3s ease;
            z-index: 1000; /* Asegurar que esté por encima de otros elementos */
        }
        
        /* Estilos para el contenedor interno del terminal */
        #terminal-basic {
            background-color: #300a24 !important; /* Forzar color de fondo */
            position: absolute;
            top: 36px; /* Altura de la barra de título */
            bottom: 22px; /* Altura de la barra de estado */
            left: 0;
            right: 0;
            overflow: hidden;
        }
        
        /* Barra de título estilo Ubuntu */
        .terminal-titlebar {
            height: 36px;
            background-color: #3e0d35 !important; /* Forzar color de barra de título */
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: flex;
            align-items: center;
            padding: 0 12px;
            color: white;
            font-family: 'Ubuntu', sans-serif;
            font-size: 14px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            z-index: 1001; /* Asegurar que esté por encima del terminal */
        }
        
        .terminal-titlebar-buttons {
            display: flex;
            margin-right: 15px;
        }
        
        .terminal-button {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .terminal-button:hover {
            transform: scale(1.1);
        }
        
        .terminal-button-close {
            background-color: #ff5f57;
        }
        
        .terminal-button-minimize {
            background-color: #ffbd2e;
        }
        
        .terminal-button-maximize {
            background-color: #28ca41;
        }
        
        /* Estilos para modal y pantalla completa */
        .terminal-fullscreen {
            position: fixed !important;
            top: 10px !important;
            left: 10px !important;
            width: calc(100vw - 20px) !important;
            height: calc(100vh - 20px) !important;
            z-index: 9999 !important;
            border-radius: 8px !important;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.6) !important;
        }
        
        #terminal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 9990;
            display: none;
            backdrop-filter: blur(3px);
        }
        
        #terminal-exit-fullscreen {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            z-index: 10000;
            display: none;
        }
        
        /* Mejorar scrollbar para terminal */
        .xterm-viewport::-webkit-scrollbar {
            width: 10px;
        }
        
        .xterm-viewport::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .xterm-viewport::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(0, 0, 0, 0.2);
        }
        
        .xterm-viewport::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.4);
        }
        
        /* Ajustes para el scroll del terminal */
        .xterm-viewport {
            overflow-y: auto !important;
            scrollbar-width: thin !important;
            scroll-behavior: smooth !important;
        }
        
        /* Asegurar que xterm ocupa todo el espacio disponible */
        .xterm {
            height: calc(100% - 36px) !important; /* Resta la altura de la barra de título */
            padding: 2px;
            background-color: #300a24 !important; /* Forzar color de fondo para xterm */
        }
        
        /* Forzar color de fondo para las capas internas de xterm */
        .xterm-screen, .xterm-viewport {
            background-color: #300a24 !important;
        }
        
        /* Animación para carga del terminal */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #terminal-container.show {
            animation: fadeIn 0.3s ease forwards;
        }
        
        /* Barra de estado del terminal */
        .terminal-statusbar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 22px;
            background-color: #32123a !important; /* Forzar color */
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 11px;
            color: #ccc;
            border-top: 1px solid #2b0821;
            z-index: 1001; /* Asegurar que esté por encima del terminal */
        }
        
        /* Indicador de conexión */
        .connection-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .connection-active {
            background-color: #4CAF50;
            box-shadow: 0 0 5px #4CAF50;
        }
        
        .connection-inactive {
            background-color: #F44336;
            box-shadow: 0 0 5px #F44336;
        }
        
        /* Estilo para el cursor */
        .terminal-cursor {
            background-color: #fff !important;
            border-color: #fff !important;
        }
        
        /* Mejor contraste para el texto */
        .xterm-text-layer {
            opacity: 1 !important;
        }
        
        /* Fix para pantalla completa en dispositivos móviles */
        @media (max-width: 768px) {
            .terminal-fullscreen {
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                border-radius: 0 !important;
            }
        }

        .connection-warning {
            background-color: #FF9800;
            box-shadow: 0 0 5px #FF9800;
        }
    </style>
@endsection

@section('content')
{{-- Meta CSRF para AJAX --}}
<meta name="csrf-token" content="{{ csrf_token() }}">

{{-- Scripts WebSockets (cargamos independientemente de app.js) --}}
<script src="https://cdn.jsdelivr.net/npm/pusher-js@8.3.0/dist/web/pusher.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/laravel-echo@1.15.3/dist/echo.iife.js"></script>

<script>
// Configuración manual de Echo para Reverb
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Variable global para controlar el estado de los WebSockets
        window.echoConnectionFailed = false;
        window.compatibilityModeActive = false;
        
        // Obtener la URL actual para extraer el host
        const currentHost = window.location.hostname === 'localhost' ? '127.0.0.1' : window.location.hostname;
        const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        
        // Configurar Echo con opciones óptimas
        window.Echo = new Echo({
            broadcaster: 'pusher',
            key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
            wsHost: currentHost,
            wsPort: {{ env("REVERB_PORT", "8080") }},
            wssPort: {{ env("REVERB_PORT", "8080") }},
            forceTLS: false,
            disableStats: true,
            enabledTransports: ['ws', 'wss'],
            cluster: 'mt1',
            authEndpoint: '/broadcasting/auth',
            encrypted: false,
            enableLogging: true,
            // Forzar modo no encriptado para conexiones locales
            useTLS: false,
            // Pequeño timeout para evitar bloqueos
            activityTimeout: 6000,
            pongTimeout: 3000
        });
        
        // Verificar estado de la conexión
        if (window.Echo.connector && window.Echo.connector.pusher) {
            // Manejar errores de conexión
            window.Echo.connector.pusher.connection.bind('error', function(error) {
                console.error('Error de conexión Pusher:', error);
                window.echoConnectionFailed = true;
            });
            
            // Manejar estado de conexión
            window.Echo.connector.pusher.connection.bind('state_change', function(states) {
                console.log('Estado de conexión Pusher cambiado:', states.previous, '->', states.current);
                
                if (states.current === 'connected') {
                    console.log('Conexión WebSocket establecida exitosamente');
                } else if (states.current === 'disconnected' || states.current === 'failed') {
                    console.warn('Conexión WebSocket desconectada o fallida');
                    window.echoConnectionFailed = true;
                }
            });
            
            usingWebsockets = true;
            console.log('Echo configurado manualmente con host:', currentHost);
        }
    } catch (error) {
        console.error('Error al configurar Echo manualmente:', error);
        window.echoConnectionFailed = true;
    }
});
</script>

<section class="section">
    <div class="section-header">
        <h1>Detalles del Host: <span id="host-hostname-title">{{ $host->hostname }}</span></h1>
        <div class="section-header-breadcrumb">
            <div class="breadcrumb-item active"><a href="{{ route('dashboard.index') }}">Dashboard</a></div>
            <div class="breadcrumb-item"><a href="{{ route('monitor.index') }}">Monitoreo</a></div>
            <div class="breadcrumb-item" id="host-breadcrumb-hostname">{{ $host->hostname }}</div>
        </div>
    </div>

    <div class="section-body">
        {{-- Fila para Alertas --}}
        <div class="row">
            <div class="col-12">
                @if(session('success'))
                    <div class="alert alert-success alert-dismissible show fade">
                        <div class="alert-body">
                            <button class="close" data-dismiss="alert"><span>&times;</span></button>
                            {{ session('success') }}
                        </div>
                    </div>
                @endif
                @if(session('error'))
                    <div class="alert alert-danger alert-dismissible show fade">
                        <div class="alert-body">
                            <button class="close" data-dismiss="alert"><span>&times;</span></button>
                            {{ session('error') }}
                        </div>
                    </div>
                @endif
                <div id="general-ajax-alert-container"></div>
            </div>
        </div>

        <div class="row">
            {{-- Columna Izquierda: Estado y Acciones --}}
            <div class="col-12 col-md-4">
                <div class="card">
                    <div class="card-header">
                        <h4>Estado del Host</h4>
                        <div class="card-header-action">
                            <button class="btn btn-primary" id="ping-host-button" data-id="{{ $host->id }}">
                                <i class="fas fa-sync"></i> Ping
                            </button>
                        </div>
                    </div>
                    <div class="card-body text-center">
                        <div id="status-badge-container" class="mb-3">
                            <span class="badge badge-{{ $host->status_color }} badge-pill">
                                    {{ $host->status_text }}
                                </span>
                            </div>
                            <div>
                                @if($host->last_seen)
                                    <p class="mb-0"><strong>Último contacto:</strong></p>
                                <p id="last-seen-text">{{ $host->last_seen->format('d/m/Y H:i:s') }} ({{ $host->last_seen->diffForHumans() }})</p>
                                @else
                                <p id="last-seen-text" class="text-muted">Sin contacto previo</p>
                                @endif
                        </div>
                        <div class="mt-4">
                            <h6 class="text-center">Información Básica</h6>
                            <div class="table-responsive">
                                <table class="table table-bordered table-sm">
                                    <tr><th style="width: 40%;">Hostname</th><td id="info-hostname">{{ $host->hostname }}</td></tr>
                                    <tr><th>Dirección IP</th><td id="info-ip_address">{{ $host->ip_address }}</td></tr>
                                    <tr><th>MAC Address</th><td id="info-mac_address">{{ $host->mac_address ?? 'No disponible' }}</td></tr>
                                    <tr><th>Descripción</th><td id="info-description">{{ $host->description ?? 'Sin descripción' }}</td></tr>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header"><h4>Acciones</h4></div>
                    <div class="card-body">
                        <div class="buttons">
                            <a href="{{ route('monitor.edit', $host->id) }}" class="btn btn-warning btn-icon icon-left btn-block mb-2">
                                <i class="fas fa-edit"></i> Editar Host
                            </a>
                            <button class="btn btn-danger btn-icon icon-left btn-block delete-host-button" data-id="{{ $host->id }}" data-hostname="{{ $host->hostname }}">
                                <i class="fas fa-trash"></i> Eliminar Host
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            {{-- Columna Derecha: Métricas y Terminal --}}
            <div class="col-12 col-md-8">
                <div class="row">
                    {{-- CPU --}}
                    <div class="col-md-6 col-sm-6 col-12">
                        <div class="card card-statistic-1">
                            <div class="card-icon bg-primary"><i class="fas fa-microchip"></i></div>
                            <div class="card-wrap">
                                <div class="card-header"><h4>CPU</h4></div>
                                <div class="card-body" id="metric-cpu-usage">
                                    {{ $host->cpu_usage !== null ? $host->cpu_usage . '%' : 'N/A' }}
                                </div>
                                @if($host->cpu_usage !== null)
                                <div class="progress mb-2" style="height: 6px;">
                                    <div id="metric-cpu-progress" class="progress-bar bg-{{ $host->cpu_color }}" role="progressbar" style="width: {{ $host->cpu_usage }}%" aria-valuenow="{{ $host->cpu_usage }}" aria-valuemin="0" aria-valuemax="100"></div>
                                </div>
                                @else
                                <div class="progress mb-2" style="height: 6px;">
                                     <div id="metric-cpu-progress" class="progress-bar bg-light" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                                </div>
                                @endif
                            </div>
                        </div>
                    </div>
                    {{-- Memoria --}}
                    <div class="col-md-6 col-sm-6 col-12">
                        <div class="card card-statistic-1">
                            <div class="card-icon bg-warning"><i class="fas fa-memory"></i></div>
                            <div class="card-wrap">
                                <div class="card-header"><h4>Memoria</h4></div>
                                <div class="card-body" id="metric-memory-usage">
                                    {{ $host->memory_usage !== null ? $host->memory_usage . '%' : 'N/A' }}
                                </div>
                                    @if($host->memory_usage !== null)
                                <div class="progress mb-2" style="height: 6px;">
                                    <div id="metric-memory-progress" class="progress-bar bg-{{ $host->memory_color }}" role="progressbar" style="width: {{ $host->memory_usage }}%" aria-valuenow="{{ $host->memory_usage }}" aria-valuemin="0" aria-valuemax="100"></div>
                                </div>
                                @else
                                <div class="progress mb-2" style="height: 6px;">
                                     <div id="metric-memory-progress" class="progress-bar bg-light" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                                </div>
                                @endif
                            </div>
                        </div>
                    </div>
                    {{-- Disco --}}
                    <div class="col-md-6 col-sm-6 col-12">
                        <div class="card card-statistic-1">
                            <div class="card-icon bg-success"><i class="fas fa-hdd"></i></div>
                            <div class="card-wrap">
                                <div class="card-header"><h4>Disco</h4></div>
                                <div class="card-body" id="metric-disk-usage">
                                    {{ $host->disk_usage !== null ? $host->disk_usage . '%' : 'N/A' }}
                                </div>
                                @if($host->disk_usage !== null)
                                <div class="progress mb-2" style="height: 6px;">
                                    <div id="metric-disk-progress" class="progress-bar bg-{{ $host->disk_color }}" role="progressbar" style="width: {{ $host->disk_usage }}%" aria-valuenow="{{ $host->disk_usage }}" aria-valuemin="0" aria-valuemax="100"></div>
                                </div>
                                @else
                                 <div class="progress mb-2" style="height: 6px;">
                                     <div id="metric-disk-progress" class="progress-bar bg-light" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                                </div>
                                @endif
                            </div>
                        </div>
                    </div>
                    {{-- Uptime --}}
                    <div class="col-md-6 col-sm-6 col-12">
                        <div class="card card-statistic-1">
                            <div class="card-icon bg-info"><i class="fas fa-clock"></i></div>
                            <div class="card-wrap">
                                <div class="card-header"><h4>Uptime</h4></div>
                                <div class="card-body" id="metric-uptime">
                                    {{ $host->uptime ?? 'N/A' }}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                {{-- Información del Sistema --}}
                <div class="card">
                    <div class="card-header"><h4>Información del Sistema</h4></div>
                    <div class="card-body" id="system-info-container">
                        @if($host->system_info && is_object($host->system_info) && count(get_object_vars($host->system_info)) > 0 || is_array($host->system_info) && count($host->system_info) > 0)
                            <div class="table-responsive">
                                <table class="table table-bordered table-sm">
                                    <tbody>
                                        @foreach($host->system_info as $key => $value)
                                            @if(is_string($value) || is_numeric($value))
                                                <tr>
                                                    <th style="width: 30%;">{{ ucfirst(str_replace('_', ' ', $key)) }}</th>
                                                    <td>{{ $value }}</td>
                                                </tr>
                                            @endif
                                        @endforeach
                                    </tbody>
                                </table>
                            </div>
                        @else
                            <div class="alert alert-info">
                                No hay información detallada del sistema disponible o no se pudo obtener.
                            </div>
                        @endif
                    </div>
                </div>
                
                {{-- Card Terminal SSH --}}
                <div class="card" id="ssh-card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h4><i class="fas fa-terminal mr-2"></i>Terminal SSH</h4>
                        <div class="card-header-action">
                            <button id="connect-terminal-button" class="btn btn-primary btn-sm">
                                <i class="fas fa-terminal"></i> Conectar
                            </button>
                            <button id="terminal-fullscreen-btn" class="btn btn-icon btn-info btn-sm" title="Pantalla completa">
                                <i class="fas fa-expand"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body p-0">
                        <div id="terminal-message-container"></div>
                        <div id="terminal-container" class="position-relative">
                            <!-- Barra de título estilo Ubuntu -->
                            <div class="terminal-titlebar">
                                <div class="terminal-titlebar-buttons">
                                    <div class="terminal-button terminal-button-close"></div>
                                    <div class="terminal-button terminal-button-minimize"></div>
                                    <div class="terminal-button terminal-button-maximize"></div>
                                </div>
                                <div class="terminal-title">
                                    root@{{ $host->hostname }}: ~
                                </div>
                            </div>
                            
                            <div id="terminal-basic" class="terminal"></div>
                            
                            <!-- Barra de estado -->
                            <div class="terminal-statusbar">
                                <div class="connection-indicator connection-inactive" id="connection-status"></div>
                                <span id="connection-text">Desconectado</span>
                                <div class="ml-auto" id="terminal-info">80×24</div>
                            </div>
                        </div>
                    </div>
                </div>

                {{-- Scripts Disponibles y Ejecución --}}
                <div class="card">
                    <div class="card-header"><h4>Ejecutar Script en Host</h4></div>
                    <div class="card-body">
                        <div class="form-group">
                            <label for="script-select">Scripts disponibles</label>
                            <div class="d-flex">
                                <select class="form-control" id="script-select" style="flex-grow: 1; margin-right: 10px;">
                                    <option value="">Cargando scripts...</option>
                                </select>
                                <button type="button" class="btn btn-light" id="btn-refresh-scripts" title="Refrescar lista de scripts">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                            </div>
                        </div>
                        <div class="mt-2">
                            <button type="button" class="btn btn-primary" id="btn-run-script" disabled>
                                <i class="fas fa-play"></i> Ejecutar Script
                            </button>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>
</section>

{{-- Modales directamente incluidos --}}
<div class="modal fade" id="deleteHostModal" tabindex="-1" role="dialog" aria-labelledby="deleteHostModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deleteHostModalLabel">Confirmar Eliminación</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <p>¿Estás seguro de que deseas eliminar el host <strong id="delete-modal-hostname"></strong>?</p>
                <p class="text-danger">Esta acción no se puede deshacer.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
                <form id="deleteHostForm" method="POST" action=""> {{-- action se pondrá con JS --}}
                    @csrf
                    @method('DELETE')
                    <button type="submit" class="btn btn-danger">Eliminar</button>
                </form>
            </div>
        </div>
    </div>
</div>

{{-- Modal para conectarse con un usuario específico --}}
<div class="modal fade" id="connectUserModal" tabindex="-1" role="dialog" aria-labelledby="connectUserModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="connectUserModalLabel">Conectar al Terminal SSH</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <form id="connectUserForm">
                    <div class="form-group">
                        <label for="sshUsername">Nombre de usuario</label>
                        <input type="text" class="form-control" id="sshUsername" value="root" autocomplete="username">
                        <small class="form-text text-muted">Introduce el nombre de usuario para la conexión SSH.</small>
                    </div>
                    <div class="form-group">
                        <label for="sshPassword">Contraseña</label>
                        <input type="password" class="form-control" id="sshPassword" value="password" autocomplete="current-password">
                        <small class="form-text text-muted">Contraseña del usuario (predeterminada: password).</small>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-primary" id="connectUserSubmit">Conectar</button>
            </div>
        </div>
    </div>
</div>

{{-- Modal para crear un nuevo usuario --}}
<div class="modal fade" id="createUserModal" tabindex="-1" role="dialog" aria-labelledby="createUserModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="createUserModalLabel">Crear nuevo usuario SSH</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info">
                    <i class="fas fa-info-circle"></i> Primero debes conectarte como root para crear un nuevo usuario.
                </div>
                <form id="createUserForm">
                    <div class="form-group">
                        <label for="newUsername">Nombre del nuevo usuario</label>
                        <input type="text" class="form-control" id="newUsername" placeholder="usuario" autocomplete="username">
                        <small class="form-text text-muted">El nombre del usuario a crear en el sistema.</small>
                    </div>
                    <div class="form-group">
                        <label for="newPassword">Contraseña</label>
                        <input type="password" class="form-control" id="newPassword" placeholder="Contraseña" autocomplete="new-password">
                        <small class="form-text text-muted">Contraseña para el nuevo usuario.</small>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-success" id="createUserSubmit">Crear Usuario</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="scriptResultModal" tabindex="-1" aria-labelledby="scriptResultModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="scriptResultModalLabel">Resultado del Script</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"> {{-- Stisla usa data-dismiss --}}
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info mb-3" id="script-info-modal">
                    <strong>Script:</strong> <span id="script-name-modal"></span><br>
                    <strong>Ejecutado en:</strong> {{ $host->hostname }} ({{ $host->ip_address }})
                </div>
                <pre class="p-3 bg-dark text-white" style="max-height: 400px; overflow-y: auto; border-radius: 5px;" id="script-output-modal">Ejecutando script...</pre>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cerrar</button>
            </div>
        </div>
    </div>
</div>

{{-- Scripts de xterm.js y addons --}}
<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-attach@0.9.0/lib/xterm-addon-attach.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-search@0.12.0/lib/xterm-addon-search.min.js"></script>

{{-- Elemento para overlay de pantalla completa --}}
<div class="terminal-fullscreen-overlay" id="terminal-overlay"></div>

@endsection

@section('scripts')
{{-- Scripts de xterm.js y addons --}}
<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-attach@0.9.0/lib/xterm-addon-attach.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-search@0.12.0/lib/xterm-addon-search.min.js"></script>

<!-- Terminal Script -->
<script>
$(document).ready(function() {
    // Variables para el terminal
    let terminal;
    let fitAddon;
    let isConnected = false;
    let sessionId = null;
    let retryConnection = false;
    let currentDirectory = '~';
    let currentPrompt = 'root@{{ $host->hostname }}:~$ ';
    let commandHistory = [];
    let historyIndex = -1;
    let currentInput = '';
    let escapeSequence = false;
    let controlSequence = '';
    let lastCommand = '';
    let cursorPosition = 0;
    let isFullscreen = false;
    let usingWebsockets = false;
    const terminalContainer = document.getElementById('terminal-container');
    const messageContainer = $('#terminal-message-container');
    const connectionStatus = document.getElementById('connection-status');
    const connectionText = document.getElementById('connection-text');
    const terminalInfo = document.getElementById('terminal-info');
    
    // Verificar que tenemos WebSockets habilitados
    usingWebsockets = typeof window.Echo !== 'undefined';

    // Variable global para detectar fallos de conexión WebSocket
    window.echoConnectionFailed = false;

    // Mostrar instrucciones para iniciar manualmente Reverb si es necesario
    function showReverbInstructions() {
        terminal.write('\r\n\x1B[1;33m⚠ WebSockets no están disponibles o no han podido conectar.\x1B[0m\r\n');
        terminal.write('\r\n\x1B[1;36mInstrucciones para habilitar WebSockets manualmente:\x1B[0m\r\n\r\n');
        terminal.write('\x1B[1;32m1. Abre una nueva ventana CMD o PowerShell\x1B[0m\r\n');
        terminal.write('\x1B[1;32m2. Navega al directorio del proyecto:\x1B[0m\r\n');
        terminal.write('\x1B[1;37m   cd "' + window.location.pathname.split('/')[0] + ':/DANI ESCRITORIO Y DESCARGAS/DANI ESCRITORIO/proyectoDA/proyecto"\x1B[0m\r\n\r\n');
        terminal.write('\x1B[1;32m3. Ejecuta el comando para iniciar Reverb:\x1B[0m\r\n');
        terminal.write('\x1B[1;37m   php artisan reverb:start\x1B[0m\r\n\r\n');
        terminal.write('\r\n\x1B[1;36mEl terminal seguirá funcionando en modo de compatibilidad mientras tanto.\x1B[0m\r\n');
    }

    // Activar modo de compatibilidad de forma más robusta
    function activateCompatibilityMode() {
        if (!window.compatibilityModeActive) {
            window.compatibilityModeActive = true;
            window.echoConnectionFailed = true;
            usingWebsockets = false;
            
            console.log('Activando modo de compatibilidad para el terminal');
            terminal.write('\r\n\x1B[1;33m⚠ Activando modo de compatibilidad (sin WebSockets)\x1B[0m\r\n');
            showReverbInstructions();
            
            // Actualizar indicador visual
            updateConnectionStatus(true, 'Conectado (Modo Compatibilidad)');
            
            // Forzar cambio de clase visual para el indicador
            $('#connection-status').removeClass('connection-active').addClass('connection-warning');
        }
    }

    // Añadir CSS para el nuevo estado de conexión
    $('head').append(`
    <style>
        .connection-warning {
            background-color: #FF9800;
            box-shadow: 0 0 5px #FF9800;
        }
    </style>
    `);

    // Función para intentar conectar al WebSocket con mejor manejo de errores
    function setupWebSocketConnection(sessionId) {
        console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
        
        // Si Echo no está disponible o la conexión falló previamente
        if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
            console.warn('Laravel Echo no está disponible o falló la conexión - el terminal funcionará en modo de compatibilidad');
            activateCompatibilityMode();
            return;
        }
        
        try {
            // Verificar estado actual de la conexión pusher
            if (window.Echo.connector && window.Echo.connector.pusher) {
                // Si ya está en estado conectado
                if (window.Echo.connector.pusher.connection.state === 'connected') {
                    subscribeToChannel();
                    return;
                }
                
                // Si está en otro estado, esperar el evento connected
                window.Echo.connector.pusher.connection.bind('connected', function() {
                    console.log('Conexión WebSocket establecida tardíamente');
                    subscribeToChannel();
                });
                
                // Evento de error
                window.Echo.connector.pusher.connection.bind('error', function(error) {
                    console.error('Error de conexión Pusher:', error);
                    activateCompatibilityMode();
                });
                
                // Después de un breve tiempo, verificar de nuevo
                setTimeout(function() {
                    if (window.Echo.connector.pusher.connection.state !== 'connected') {
                        console.warn('Conexión WebSocket fallida - cambiando a modo de compatibilidad');
                        activateCompatibilityMode();
                    }
                }, 3000);
            } else {
                console.warn('Configuración de Echo incompleta - cambiando a modo de compatibilidad');
                activateCompatibilityMode();
            }
            
            function subscribeToChannel() {
                // Primero intentar con un canal privado
                try {
                    window.Echo.private(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
                } catch (error) {
                    console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                    
                    // Si falla, intentar con un canal público
                    try {
                        window.Echo.channel(`terminal.${sessionId}`)
                            .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                        console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                    } catch (innerError) {
                        console.error('Error al suscribirse a canal público:', innerError);
                        activateCompatibilityMode();
                        return;
                    }
                }
                
                updateConnectionStatus(true, `Conectado: WebSockets activos`);
                usingWebsockets = true;
            }
        } catch (error) {
            console.error('Error al configurar WebSocket:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
            activateCompatibilityMode();
        }
    }

    // Mejorar la función fallbackToAjax para una experiencia más fluida
    function fallbackToAjax(requestData) {
        // Cancelar cualquier timeout pendiente
        if (window.lastCommandTimeout) {
            clearTimeout(window.lastCommandTimeout);
            window.lastCommandTimeout = null;
        }
        
        // Si no estamos ya en modo de compatibilidad, activarlo
        if (!window.compatibilityModeActive && usingWebsockets) {
            activateCompatibilityMode();
        }
        
        // Mostrar indicador de que estamos usando AJAX
        console.log('Ejecutando comando via AJAX:', requestData.command);
        
        $.ajax({
            url: '/api/terminal/send',
            type: 'POST',
            data: {
                sessionId: requestData.session_id,
                command: requestData.command,
                _token: '{{ csrf_token() }}'
            },
            success: function(response) {
                if (response.success) {
                    // Procesar la respuesta directamente
                    if (response.output) {
                        // Procesar salida
                        let formattedOutput = formatOutput(response.output);
                        terminal.write(formattedOutput);
                        
                        // Actualizar directorio si se proporciona
                        if (response.currentDirectory) {
                            const currentUser = getCurrentUserFromPrompt();
                            currentDirectory = response.currentDirectory;
                            currentPrompt = `${currentUser}@{{ $host->hostname }}:${formatPath(currentDirectory)}$ `;
                            updateTerminalTitle(currentUser);
                        }
                        
                        // Mostrar nuevo prompt
                        terminal.write('\r\n' + currentPrompt);
                        
                        // Forzar scroll al fondo
                        scrollToBottom();
                    }
                } else {
                    terminal.write('\r\n\x1B[1;31m✗ Error: ' + (response.message || 'Error desconocido') + '\x1B[0m\r\n' + currentPrompt);
                }
            },
            error: function(xhr) {
                let message = 'Error al ejecutar el comando';
                if (xhr.responseJSON && xhr.responseJSON.message) {
                    message = xhr.responseJSON.message;
                }
                
                terminal.write('\r\n\x1B[1;31m✗ Error: ' + message + '\x1B[0m\r\n' + currentPrompt);
                
                // Si hay error de conexión, marcar como desconectado
                if (xhr.status === 0 || xhr.status >= 500) {
                    isConnected = false;
                    updateConnectionStatus(false, 'Desconectado: Error en el servidor');
                    $('#connect-terminal-button').prop('disabled', false).html('<i class="fas fa-terminal"></i> Conectar');
                }
            }
        });
    }

    // Intentar asegurar que Echo esté disponible
    if (!usingWebsockets) {
        console.warn('Laravel Echo no está disponible - el terminal funcionará en modo de compatibilidad');
        
        // Intentar configurar Echo manualmente si no está disponible
        try {
            // Obtener la URL actual para extraer el host
            const currentHost = window.location.hostname;
            const currentProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
            
            window.Echo = new Echo({
                broadcaster: 'pusher',
                key: '{{ env("REVERB_APP_KEY", "proyectoDArevkey") }}',
                wsHost: currentHost,
                wsPort: {{ env("REVERB_PORT", "8080") }},
                wssPort: {{ env("REVERB_PORT", "8080") }},
                forceTLS: false,
                disableStats: true,
                enabledTransports: ['ws', 'wss'],
                cluster: 'mt1',
                authEndpoint: '/broadcasting/auth',
                encrypted: false,
                enableLogging: true
            });
            
            // Verificar estado de la conexión
            if (window.Echo.connector && window.Echo.connector.pusher) {
                window.Echo.connector.pusher.connection.bind('error', function(error) {
                    console.error('Error de conexión Pusher:', error);
                    window.echoConnectionFailed = true;
                });
                
                usingWebsockets = true;
                console.log('Echo configurado manualmente desde el terminal con host:', currentHost);
            }
        } catch (error) {
            console.error('Error al configurar Echo manualmente:', error);
            window.echoConnectionFailed = true;
        }
    } else {
        console.log('Laravel Echo disponible - el terminal usará WebSockets');
        
        // Verificar estado de la conexión existente
        if (window.Echo && window.Echo.connector && window.Echo.connector.pusher) {
            if (window.Echo.connector.pusher.connection.state !== 'connected') {
                console.warn('Echo existe pero la conexión no está activa:', window.Echo.connector.pusher.connection.state);
                
                // Monitorear eventos de error
                window.Echo.connector.pusher.connection.bind('error', function(error) {
                    console.error('Error de conexión Pusher:', error);
                    window.echoConnectionFailed = true;
                });
                
                // Verificar estado después de un tiempo
                setTimeout(function() {
                    if (window.Echo.connector.pusher.connection.state !== 'connected') {
                        console.warn('Conexión WebSocket no establecida después de 3 segundos');
                        window.echoConnectionFailed = true;
                    }
                }, 3000);
            }
        }
    }
    
    // Configurar tema Ubuntu mejorado
    const ubuntuTheme = {
        background: '#300A24',
        foreground: '#FFFFFF',
        cursor: '#FFFFFF',
        cursorAccent: '#300A24',
        selection: 'rgba(255, 255, 255, 0.3)',
        black: '#2E3436',
        red: '#CC0000',
        green: '#4E9A06',
        yellow: '#C4A000',
        blue: '#3465A4',
        magenta: '#75507B',
        cyan: '#06989A',
        white: '#D3D7CF',
        brightBlack: '#555753',
        brightRed: '#EF2929',
        brightGreen: '#8AE234',
        brightYellow: '#FCE94F',
        brightBlue: '#729FCF',
        brightMagenta: '#AD7FA8',
        brightCyan: '#34E2E2',
        brightWhite: '#EEEEEC'
    };
    
    // Botón de conexión
    $('#connect-terminal-button').on('click', function() {
        // Si ya está conectado, desconectar
        if (isConnected) {
            disconnectTerminal();
            return;
        }
        
        // Iniciar directamente la terminal con usuario root sin mostrar modal
        const $btn = $('#connect-terminal-button');
        $btn.prop('disabled', true).html('<i class="fas fa-spinner fa-spin"></i> Conectando...');
        
        // Usuario predeterminado
        const username = 'root';
        currentPrompt = `${username}@{{ $host->hostname }}:~$ `;
        
        // Inicializar terminal y conectar
        initTerminal(username);
    });
    
    // Ocultar el botón de agregar usuario
    $('#add-user-button').hide();
    
    // Mostrar mensajes en el contenedor
    function showMessage(message, type = 'info') {
        messageContainer.html(`
            <div class="alert alert-${type} alert-dismissible show fade">
                <div class="alert-body">
                    <button class="close" data-dismiss="alert"><span>&times;</span></button>
                    ${message}
                </div>
            </div>
        `);
        
        // Auto-ocultar después de 5 segundos
        setTimeout(() => {
            $('.alert').alert('close');
        }, 5000);
    }
    
    // Función para asegurar que el terminal siempre hace scroll al fondo
    function scrollToBottom() {
        setTimeout(() => {
            // Usar scrollToBottom de xterm.js
            terminal.scrollToBottom();
            
            // Forzar scroll directamente en el DOM
            const viewport = document.querySelector('.xterm-viewport');
            if (viewport) {
                viewport.scrollTop = viewport.scrollHeight;
                // Forzar un segundo scroll después de un breve retraso para asegurar que funciona
                setTimeout(() => {
                    viewport.scrollTop = viewport.scrollHeight + 1000; // Valor grande para forzar al final
                }, 10);
            }
        }, 10);
    }
    
    // Inicializar terminal
    function initTerminal(username = 'root') {
        // Si ya existe un terminal, destruirlo
        if (terminal) {
            terminal.dispose();
        }
        
        // Mostrar contenedor con animación
        $('#terminal-container').show().addClass('show');
        
        // Forzar color de fondo
        $('#terminal-basic').css('background-color', '#300A24');
        
        // Inicializar terminal xterm.js con opciones mejoradas
        terminal = new Terminal({
            cursorBlink: true,
            theme: ubuntuTheme,
            fontFamily: '"Ubuntu Mono", "DejaVu Sans Mono", "Consolas", monospace',
            fontSize: 16,
            fontWeight: 'normal',
            lineHeight: 1.2,
            scrollback: 10000,     // Aumentar buffer de scrollback
            allowTransparency: true,
            windowsMode: false,    // Desactivar modo Windows para mejorar compatibilidad
            cursorStyle: 'block',  // Cursor de bloque como en Ubuntu
            rendererType: 'canvas', // Mejor rendimiento
            cols: 80,              // Ancho estándar para terminal
            rows: 24,              // Alto estándar para terminal
            convertEol: true,      // Convertir final de línea automáticamente
            scrollOnUserInput: true, // Scroll con entrada de usuario
            disableStdin: false,   // Habilitar entrada estándar
            smoothScrollDuration: 300,
            macOptionIsMeta: true,
            bellStyle: 'sound',
            rightClickSelectsWord: true
        });
        
        // Actualizar información de tamaño
        terminalInfo.textContent = `${terminal.cols}×${terminal.rows}`;
        
        // Configurar addons
        fitAddon = new FitAddon.FitAddon();
        terminal.loadAddon(fitAddon);
        terminal.loadAddon(new WebLinksAddon.WebLinksAddon());
        const searchAddon = new SearchAddon.SearchAddon();
        terminal.loadAddon(searchAddon);
        
        // Abrir terminal en el contenedor
        terminal.open(document.getElementById('terminal-basic'));
        
        // Forzar nuevamente colores después de abrir
        $('.xterm-screen, .xterm-viewport').css('background-color', '#300A24');
        
        fitAddon.fit();
        
        // Banner inicial de bienvenida con animación mejorada
        terminal.write('\r\n\x1B[1;36m┌─────────────────────────────────────────────┐\x1B[0m\r\n');
        terminal.write('\x1B[1;36m│\x1B[0m \x1B[1;32m¡Bienvenido al terminal SSH de Ubuntu!\x1B[0m      \x1B[1;36m│\x1B[0m\r\n');
        terminal.write('\x1B[1;36m└─────────────────────────────────────────────┘\x1B[0m\r\n\r\n');
        
        // Conectar a SSH con el usuario especificado
        connectToSsh(username);
        
        // Manejar entrada del teclado
        terminal.onData(handleTerminalInput);
        
        // Manejar cambio de tamaño
        terminal.onResize(handleTerminalResize);
        
        // Implementar búsqueda con Ctrl+F
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 'f' && isConnected) {
                event.preventDefault();
                searchAddon.findNext('');
            }
        });
        
        // Asegurar que el contenedor tiene una altura mínima adecuada
        const termHeight = isFullscreen ? $(window).height() - 100 : 450;
        $('#terminal-container').css('min-height', termHeight + 'px');
        
        // Ajustar tamaño de terminal al mostrar
        setTimeout(function() {
            fitAddon.fit();
            scrollToBottom();
            
            // Actualizar información de tamaño
            terminalInfo.textContent = `${terminal.cols}×${terminal.rows}`;
            
            // Forzar colores de nuevo después de un momento
            $('.xterm-screen, .xterm-viewport').css('background-color', '#300A24');
        }, 100);
        
        // Configurar MutationObserver para detectar cambios en el contenido y hacer scroll
        setTimeout(() => {
            const targetNode = document.querySelector('.xterm-screen');
            if (targetNode) {
                const observer = new MutationObserver(() => {
                    scrollToBottom();
                    // Asegurar color de fondo
                    $('.xterm-screen, .xterm-viewport').css('background-color', '#300A24');
                });
                
                observer.observe(targetNode, { childList: true, subtree: true, characterData: true });
            }
        }, 500);
    }
    
    // Manejar eventos de cambio de tamaño del terminal
    function handleTerminalResize(size) {
        console.log('Terminal resized:', size);
        terminalInfo.textContent = `${size.cols}×${size.rows}`;
        
        // Si hay una conexión activa, enviar el nuevo tamaño al servidor
        if (isConnected && sessionId) {
            $.ajax({
                url: '/api/terminal/resize',
                type: 'POST',
                data: {
                    sessionId: sessionId,
                    cols: size.cols,
                    rows: size.rows,
                    _token: '{{ csrf_token() }}'
                },
                error: function(xhr) {
                    console.error('Error al redimensionar terminal:', xhr);
                }
            });
        }
        
        // Asegurar color de fondo después del resize
        setTimeout(() => {
            $('.xterm-screen, .xterm-viewport').css('background-color', '#300A24');
        }, 50);
    }
    
    // Función para iniciar la conexión verificando primero WebSockets
    function connectToSsh(username = 'root') {
        terminal.clear();
        updateConnectionStatus(false, 'Iniciando WebSocket...');
        terminal.write(`\r\n\x1B[1;34m● Iniciando servidor WebSocket Reverb...\x1B[0m\r\n`);
        
        // Verificar si ya sabemos que WebSockets no están funcionando
        if (window.echoConnectionFailed) {
            terminal.write(`\r\n\x1B[1;33m⚠ WebSockets no disponibles. Continuando en modo de compatibilidad.\x1B[0m\r\n`);
            usingWebsockets = false;
            connectToSSHServer(username);
            return;
        }
        
        // Variable para controlar si se intenta sin WebSockets
        let skipReverb = false;
        
        // Verificar rápidamente la disponibilidad del servidor Reverb
        $.ajax({
            url: '/api/websocket/status',
            type: 'GET',
            timeout: 3000,
            success: function(response) {
                if (response.running) {
                    terminal.write(`\r\n\x1B[1;32m✓ Servidor WebSocket activo\x1B[0m\r\n`);
                    usingWebsockets = true;
                    connectToSSHServer(username);
                } else {
                    // Si no está activo, intentar iniciarlo
                    startReverbServer(username);
                }
            },
            error: function() {
                // Error al verificar estado, intentar iniciarlo de todos modos
                startReverbServer(username);
            }
        });
        
        // Función para iniciar el servidor Reverb
        function startReverbServer(username) {
            // Iniciar el servidor Reverb (con tiempo de espera)
            const reverbPromise = new Promise((resolve, reject) => {
                // Establecer un tiempo máximo de espera
                const timeout = setTimeout(() => {
                    reject('Timeout al iniciar Reverb');
                }, 8000);
                
                $.ajax({
                    url: '/api/websocket/start',
                    type: 'POST',
                    headers: {
                        'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
                    },
                    success: function(response) {
                        clearTimeout(timeout);
                        console.log('Respuesta del servidor WebSocket:', response);
                        resolve(response);
                    },
                    error: function(xhr, status, error) {
                        clearTimeout(timeout);
                        console.error('Error al iniciar servidor WebSocket:', error);
                        reject(error);
                    }
                });
            });
            
            // Manejar el resultado de iniciar Reverb
            reverbPromise.then(
                (response) => {
                    terminal.write(`\r\n\x1B[1;32m✓ ${response.message || 'Servidor WebSocket iniciado'}\x1B[0m\r\n`);
                    usingWebsockets = true;
                    
                    // Esperar un momento para dar tiempo al servidor a iniciar
                    setTimeout(function() {
                        connectToSSHServer(username);
                    }, 1000);
                },
                (error) => {
                    console.error('Error iniciando Reverb:', error);
                    terminal.write(`\r\n\x1B[1;33m⚠ No se pudo iniciar Reverb: ${error}\x1B[0m\r\n`);
                    terminal.write(`\r\n\x1B[1;33m⚠ Continuando en modo de compatibilidad sin WebSockets...\x1B[0m\r\n`);
                    usingWebsockets = false;
                    window.echoConnectionFailed = true;
                    connectToSSHServer(username);
                }
            );
        }
    }
    
    // Actualizar el indicador de estado de conexión
    function updateConnectionStatus(isActive, text) {
        connectionStatus.className = `connection-indicator ${isActive ? 'connection-active' : 'connection-inactive'}`;
        connectionText.textContent = text;
    }
    
    // Actualizar el título de la terminal
    function updateTerminalTitle(username = 'root') {
        $('.terminal-title').text(`${username}@{{ $host->hostname }}: ${formatPath(currentDirectory)}`);
    }

    // Función para configurar la conexión WebSocket
    function setupWebSocketConnection(sessionId) {
        console.log('Configurando WebSocket para el terminal con sessionId:', sessionId);
        
        // Si Echo no está disponible o la conexión falló previamente
        if (typeof window.Echo === 'undefined' || window.echoConnectionFailed === true) {
            console.warn('Laravel Echo no está disponible o falló la conexión - el terminal funcionará en modo de compatibilidad');
            terminal.write('\r\n\x1B[1;33m⚠ WebSockets no disponibles. Funcionando en modo de compatibilidad.\x1B[0m\r\n');
            usingWebsockets = false;
            return;
        }
        
        try {
            // Verificar estado actual de la conexión pusher
            if (window.Echo.connector && window.Echo.connector.pusher && 
                window.Echo.connector.pusher.connection.state !== 'connected') {
                
                // Si no está conectado, intentar una vez más escuchar el evento de conexión
                window.Echo.connector.pusher.connection.bind('connected', function() {
                    console.log('Conexión WebSocket establecida tardíamente');
                    subscribeToChannel();
                });
                
                // Después de un breve tiempo, verificar de nuevo
                setTimeout(function() {
                    if (window.Echo.connector.pusher.connection.state !== 'connected') {
                        console.warn('Conexión WebSocket fallida - cambiando a modo de compatibilidad');
                        terminal.write('\r\n\x1B[1;33m⚠ Conexión WebSocket fallida. Funcionando en modo de compatibilidad.\x1B[0m\r\n');
                        usingWebsockets = false;
                    }
                }, 2000);
            } else {
                // Intentar suscribirse al canal inmediatamente
                subscribeToChannel();
            }
            
            function subscribeToChannel() {
                // Primero intentar con un canal privado
                try {
                    window.Echo.private(`terminal.${sessionId}`)
                        .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                    console.log('WebSocket configurado correctamente para el canal privado:', `terminal.${sessionId}`);
                } catch (error) {
                    console.error('Error al suscribirse al canal privado, probando con canal público:', error);
                    
                    // Si falla, intentar con un canal público
                    try {
                        window.Echo.channel(`terminal.${sessionId}`)
                            .listen('TerminalOutputReceived', processWebSocketResponse);
                        
                        console.log('WebSocket configurado correctamente para el canal público:', `terminal.${sessionId}`);
                    } catch (innerError) {
                        console.error('Error al suscribirse a canal público:', innerError);
                        window.echoConnectionFailed = true;
                        usingWebsockets = false;
                        terminal.write('\r\n\x1B[1;33m⚠ Error al configurar WebSockets. Funcionando en modo de compatibilidad.\x1B[0m\r\n');
                        return;
                    }
                }
                
                updateConnectionStatus(true, `Conectado: WebSockets activos`);
                usingWebsockets = true;
            }
        } catch (error) {
            console.error('Error al configurar WebSocket:', error);
            terminal.write('\r\n\x1B[1;31m✗ Error al configurar WebSocket: ' + error.message + '\x1B[0m\r\n');
            terminal.write('\r\n\x1B[1;33m⚠ Continuando en modo de compatibilidad sin WebSockets\x1B[0m\r\n');
            usingWebsockets = false;
            window.echoConnectionFailed = true;
        }
    }
    
    // Manejar entrada del usuario en el terminal
    function handleTerminalInput(data) {
        // Si la conexión está en proceso de reintento
        if (retryConnection) {
            retryConnection = false;
            const username = 'root';
            currentPrompt = `${username}@{{ $host->hostname }}:~$ `;
            connectToSSHServer(username);
            return;
        }
        
        // Si no hay conexión activa, ignorar entrada
        if (!isConnected) {
            return;
        }
        
        // Caracteres especiales
        const keyCode = data.charCodeAt(0);
        
        // Tecla Enter
        if (data === '\r') {
            const command = currentInput.trim();
            lastCommand = command;
            
            // Resetear historial si se ingresa un comando
            if (command) {
                commandHistory.unshift(command);
                if (commandHistory.length > 50) { // Limitar historial a 50 comandos
                    commandHistory.pop();
                }
            }
            
            // Resetear índice de historial
            historyIndex = -1;
            
            // Resetear entrada actual
            currentInput = '';
            cursorPosition = 0;
            
            // Manejar comandos especiales
            if (command === 'clear') {
                terminal.clear();
                terminal.write(currentPrompt);
                return;
            }
            
            // Salto de línea
            terminal.write('\r\n');
            
            // Ejecutar el comando
            if (command) {
                executeCommand(command);
            } else {
                // Si no hay comando, simplemente mostrar el prompt
                terminal.write(currentPrompt);
            }
            return;
        }
        
        // Tecla Tab (autocompletado)
        if (data === '\t') {
            // Simple autocompletado, en entorno real esto debería consultar al servidor
            return;
        }
        
        // Teclas de escape (flechas, etc.)
        if (keyCode === 27) {
            escapeSequence = true;
            controlSequence = '';
            return;
        }
        
        // Procesando secuencia de escape
        if (escapeSequence) {
            controlSequence += data;
            
            // Flecha arriba: Historial previo
            if (controlSequence === '[A') {
                if (commandHistory.length > 0) {
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                    }
                    
                    // Borrar línea actual
                    terminal.write('\x1b[2K\r' + currentPrompt);
                    
                    // Escribir comando del historial
                    currentInput = commandHistory[historyIndex];
                    terminal.write(currentInput);
                    cursorPosition = currentInput.length;
                }
                escapeSequence = false;
                return;
            }
            
            // Flecha abajo: Historial siguiente
            if (controlSequence === '[B') {
                // Borrar línea actual
                terminal.write('\x1b[2K\r' + currentPrompt);
                
                if (historyIndex > 0) {
                    historyIndex--;
                    currentInput = commandHistory[historyIndex];
                } else {
                    historyIndex = -1;
                    currentInput = '';
                }
                
                // Escribir comando o línea vacía
                terminal.write(currentInput);
                cursorPosition = currentInput.length;
                escapeSequence = false;
                return;
            }
            
            // Flecha derecha: mover cursor a la derecha
            if (controlSequence === '[C') {
                if (cursorPosition < currentInput.length) {
                    cursorPosition++;
                    terminal.write(data);
                }
                escapeSequence = false;
                return;
            }
            
            // Flecha izquierda: mover cursor a la izquierda
            if (controlSequence === '[D') {
                if (cursorPosition > 0) {
                    cursorPosition--;
                    terminal.write(data);
                }
                escapeSequence = false;
                return;
            }
            
            // Home: ir al inicio de la línea
            if (controlSequence === '[H' || controlSequence === '[1~') {
                terminal.write('\r' + currentPrompt);
                cursorPosition = 0;
                escapeSequence = false;
                return;
            }
            
            // End: ir al final de la línea
            if (controlSequence === '[F' || controlSequence === '[4~') {
                terminal.write('\r' + currentPrompt + currentInput);
                cursorPosition = currentInput.length;
                escapeSequence = false;
                return;
            }
            
            // Delete: borrar carácter a la derecha
            if (controlSequence === '[3~') {
                if (cursorPosition < currentInput.length) {
                    currentInput = currentInput.slice(0, cursorPosition) + currentInput.slice(cursorPosition + 1);
                    // Redibuja desde la posición actual
                    terminal.write('\x1b[K' + currentInput.slice(cursorPosition));
                    // Reposiciona el cursor
                    terminal.write('\x1b[' + (currentInput.length - cursorPosition) + 'D');
                }
                escapeSequence = false;
                return;
            }
            
            // Si la secuencia está completa (terminada en una letra)
            if (controlSequence.match(/[a-zA-Z]/)) {
                escapeSequence = false;
                return;
            }
            
            // Si la secuencia no es reconocida y llega a cierta longitud, cancelarla
            if (controlSequence.length >= 5) {
                escapeSequence = false;
                return;
            }
            
            return;
        }
        
        // Tecla Backspace
        if (keyCode === 127 || keyCode === 8) {
            if (cursorPosition > 0) {
                if (cursorPosition === currentInput.length) {
                    currentInput = currentInput.slice(0, -1);
                    terminal.write('\b \b');
                } else {
                    // Borrar carácter en posición del cursor
                    currentInput = currentInput.slice(0, cursorPosition - 1) + currentInput.slice(cursorPosition);
                    cursorPosition--;
                    
                    // Redibuja toda la línea
                    terminal.write('\r\x1b[K' + currentPrompt + currentInput);
                    
                    // Reposiciona el cursor
                    terminal.write('\x1b[' + (currentInput.length - cursorPosition) + 'D');
                }
            }
            return;
        }
        
        // Ctrl+C
        if (keyCode === 3) {
            terminal.write('^C\r\n' + currentPrompt);
            currentInput = '';
            cursorPosition = 0;
            return;
        }
        
        // Ctrl+D (EOF) - solo si la línea está vacía
        if (keyCode === 4 && currentInput === '') {
            terminal.write('^D\r\n');
            disconnectTerminal();
            return;
        }
        
        // Tecla Ctrl+L (clear)
        if (keyCode === 12) {
            terminal.clear();
            terminal.write(currentPrompt + currentInput);
            return;
        }
        
        // Caracteres imprimibles
        if (keyCode >= 32) {
            // Insertar carácter en la posición actual del cursor
            if (cursorPosition === currentInput.length) {
                currentInput += data;
                terminal.write(data);
            } else {
                currentInput = currentInput.slice(0, cursorPosition) + data + currentInput.slice(cursorPosition);
                
                // Redibuja desde la posición actual
                terminal.write(data + currentInput.slice(cursorPosition));
                
                // Reposiciona el cursor
                cursorPosition++;
                terminal.write('\x1b[' + (currentInput.length - cursorPosition) + 'D');
            }
            
            cursorPosition++;
        }
    }
    
    // Ejecutar comando en el servidor
    function executeCommand(command, element) {
        // Verificación para detectar si hay un mensaje inicial
        if (command === 'cd ~') {
            // Comprobar si los WebSockets fallaron después de intentar la conexión
            setTimeout(function() {
                if (window.echoConnectionFailed || window.compatibilityModeActive) {
                    activateCompatibilityMode();
                } else if (usingWebsockets) {
                    terminal.write('\r\n\x1B[1;32m✓ WebSockets conectados correctamente\x1B[0m\r\n');
                }
            }, 2000);
        }

        // Esconder elemento de historial si es necesario
        if (element) {
            $(element).hide();
        }

        // Mostrar comando en terminal con el formato correcto
        const prompt = getCurrentUserFromPrompt() + '@{{ $host->hostname }}:' + formatPath(currentDirectory);
        terminal.write('\r\n\x1B[1;32m' + prompt + '$\x1B[0m ' + command + '\r\n');

        // Si no hay conexión activa, mostrar error
        if (!isConnected || !sessionId) {
            terminal.write('\r\n\x1B[1;31m✗ Error: No hay una conexión SSH activa\x1B[0m\r\n');
            return;
        }

        // Preparar datos para la solicitud
        const requestData = {
            command: command,
            session_id: sessionId
        };

        // Si estamos en modo de compatibilidad, usar AJAX directamente
        if (window.compatibilityModeActive || window.echoConnectionFailed || !usingWebsockets || !window.Echo) {
            fallbackToAjax(requestData);
            return;
        }

        // Si tenemos WebSockets activos, usar canal para ejecutar el comando
        try {
            console.log('Ejecutando comando via WebSockets:', command);
            
            // Intentar con whisper primero
            let whisperSent = false;
            try {
                window.Echo.private('terminal.' + sessionId)
                    .whisper('command', {
                        command: command
                    });
                whisperSent = true;
                console.log('Comando enviado via whisper');
            } catch (error) {
                console.error('Error al enviar comando por whisper:', error);
            }
            
            // Si whisper falla, intentar con endpoint HTTP especial para WebSockets
            if (!whisperSent) {
                console.log('Whisper falló, intentando con endpoint HTTP para WebSockets');
                $.ajax({
                    url: '/api/websocket/command',
                    type: 'POST',
                    data: {
                        sessionId: sessionId,
                        command: command,
                        _token: '{{ csrf_token() }}'
                    },
                    success: function(response) {
                        console.log('Comando enviado exitosamente via endpoint WebSocket');
                    },
                    error: function(xhr, status, error) {
                        console.error('Error al enviar comando via endpoint WebSocket:', error);
                        // Si también falla, usar el fallback a AJAX tradicional
                        fallbackToAjax(requestData);
                    }
                });
            }
            
            // Establecer un timeout para verificar si recibimos respuesta del WebSocket
            const commandTimeout = setTimeout(function() {
                console.warn('No se recibió respuesta del comando via WebSockets en 3 segundos, usando AJAX como respaldo');
                fallbackToAjax(requestData);
            }, 3000);
            
            // Almacenar el timeout para cancelarlo si recibimos respuesta
            window.lastCommandTimeout = commandTimeout;
            
        } catch (error) {
            console.error('Error al enviar comando por WebSockets:', error);
            fallbackToAjax(requestData);
        }
    }

    // Función de respaldo para ejecutar comandos vía AJAX si WebSockets falla
    function fallbackToAjax(requestData) {
        // Cancelar cualquier timeout pendiente
        if (window.lastCommandTimeout) {
            clearTimeout(window.lastCommandTimeout);
            window.lastCommandTimeout = null;
        }
        
        // Mostrar indicador de que estamos usando AJAX
        console.log('Ejecutando comando via AJAX:', requestData.command);
        
        $.ajax({
            url: '/api/terminal/send',
            type: 'POST',
            data: {
                sessionId: requestData.session_id,
                command: requestData.command,
                _token: '{{ csrf_token() }}'
            },
            success: function(response) {
                if (response.success) {
                    // Si no estamos usando WebSockets, procesar la respuesta directamente
                    if (!usingWebsockets && response.output) {
                        // Procesar salida
                        let formattedOutput = formatOutput(response.output);
                        terminal.write(formattedOutput);
                        
                        // Actualizar directorio si se proporciona
                        if (response.currentDirectory) {
                            const currentUser = getCurrentUserFromPrompt();
                            currentDirectory = response.currentDirectory;
                            currentPrompt = `${currentUser}@{{ $host->hostname }}:${formatPath(currentDirectory)}$ `;
                            updateTerminalTitle(currentUser);
                        }
                        
                        // Mostrar nuevo prompt
                        terminal.write('\r\n' + currentPrompt);
                    }
                } else {
                    terminal.write('\r\n\x1B[1;31m✗ Error: ' + (response.message || 'Error desconocido') + '\x1B[0m\r\n' + currentPrompt);
                }
            },
            error: function(xhr) {
                let message = 'Error al ejecutar el comando';
                if (xhr.responseJSON && xhr.responseJSON.message) {
                    message = xhr.responseJSON.message;
                }
                
                terminal.write('\r\n\x1B[1;31m✗ Error: ' + message + '\x1B[0m\r\n' + currentPrompt);
                
                // Si hay error de conexión, marcar como desconectado
                if (xhr.status === 0 || xhr.status >= 500) {
                    isConnected = false;
                    updateConnectionStatus(false, 'Desconectado: Error en el servidor');
                    $('#connect-terminal-button').prop('disabled', false).html('<i class="fas fa-terminal"></i> Conectar');
                }
            }
        });
    }
    
    // Función para desconectar el terminal
    function disconnectTerminal() {
        if (!isConnected || !sessionId) {
            return;
        }
        
        terminal.write('\r\n\x1B[1;34m● Cerrando sesión SSH...\x1B[0m\r\n');
        
        $.ajax({
            url: '/api/terminal/disconnect',
            type: 'POST',
            data: {
                sessionId: sessionId,
                _token: '{{ csrf_token() }}'
            },
            success: function(response) {
                if (response.success) {
                    terminal.write('\r\n\x1B[1;32m✓ Sesión terminada correctamente\x1B[0m\r\n');
                } else {
                    terminal.write('\r\n\x1B[1;31m✗ Error al cerrar sesión: ' + response.message + '\x1B[0m\r\n');
                }
                
                isConnected = false;
                sessionId = null;
                updateConnectionStatus(false, 'Desconectado');
                $('#connect-terminal-button').prop('disabled', false).html('<i class="fas fa-terminal"></i> Conectar');
                
                // Desconectar Echo si está disponible
                if (window.Echo) {
                    try {
                        window.Echo.leave(`terminal.${sessionId}`);
                    } catch (error) {
                        console.error('Error al desconectar WebSocket:', error);
                    }
                }
            },
            error: function(xhr) {
                let message = 'Error al cerrar sesión';
                if (xhr.responseJSON && xhr.responseJSON.message) {
                    message = xhr.responseJSON.message;
                }
                
                terminal.write('\r\n\x1B[1;31m✗ Error: ' + message + '\x1B[0m\r\n');
                
                isConnected = false;
                sessionId = null;
                updateConnectionStatus(false, 'Desconectado con errores');
                $('#connect-terminal-button').prop('disabled', false).html('<i class="fas fa-terminal"></i> Conectar');
            }
        });
    }
    
    // Función para obtener el usuario actual del prompt
    function getCurrentUserFromPrompt() {
        // Extraer el nombre de usuario del prompt actual
        // Formato esperado: 'usuario@hostname:~$ '
        const promptMatch = currentPrompt.match(/^([^@]+)@/);
        return promptMatch ? promptMatch[1] : 'root';
    }
    
    // Formatear salida para terminales
    function formatOutput(output) {
        // Asegurarse de que sea string
        output = String(output);
        
        // Reemplazar secuencias comunes del terminal
        output = output.replace(/\r?\n/g, '\r\n');
        
        return output;
    }
    
    // Formatear rutas para mostrar en el prompt
    function formatPath(path) {
        // Si es el directorio home, mostrar como ~
        const username = getCurrentUserFromPrompt();
        const homeDir = `/home/${username}`;
        
        if (path === homeDir) {
            return '~';
        }
        
        // Si está dentro del home, reemplazar con ~
        if (path.startsWith(homeDir + '/')) {
            return '~' + path.substring(homeDir.length);
        }
        
        return path;
    }
    
    // Control de pantalla completa
    $('#terminal-fullscreen-btn').on('click', function() {
        toggleFullscreen();
    });
    
    // Botones de la barra de título
    $('.terminal-button-close').on('click', function() {
        if (isConnected) {
            disconnectTerminal();
        } else {
            $('#terminal-container').hide().removeClass('show');
        }
    });
    
    $('.terminal-button-minimize').on('click', function() {
        $('#terminal-container').hide().removeClass('show');
    });
    
    $('.terminal-button-maximize').on('click', function() {
        toggleFullscreen();
    });
    
    // Función para alternar modo pantalla completa
    function toggleFullscreen() {
        isFullscreen = !isFullscreen;
        
        // Crear el botón de salir si no existe
        if (!$('#terminal-exit-fullscreen').length) {
            $('body').append('<button id="terminal-exit-fullscreen" class="btn btn-sm btn-dark"><i class="fas fa-compress"></i> Salir</button>');
            
            // Evento para el botón de salir
            $('#terminal-exit-fullscreen').on('click', function() {
                toggleFullscreen();
            });
        }
        
        if (isFullscreen) {
            // Mostrar overlay y añadir clase de pantalla completa
            $('#terminal-overlay').fadeIn(200);
            $('#terminal-container').addClass('terminal-fullscreen');
            $('#terminal-exit-fullscreen').show();
            
            // Asegurar que se hace scroll al contenido
            $('html, body').css({
                overflow: 'hidden',
                height: '100%'
            });
        } else {
            // Ocultar overlay y remover clase de pantalla completa
            $('#terminal-overlay').fadeOut(200);
            $('#terminal-container').removeClass('terminal-fullscreen');
            $('#terminal-exit-fullscreen').hide();
            
            // Restaurar scroll
            $('html, body').css({
                overflow: '',
                height: ''
            });
        }
        
        // Ajustar tamaño del terminal al nuevo contenedor
        setTimeout(function() {
            if (terminal && fitAddon) {
                fitAddon.fit();
                
                // Actualizar información de tamaño
                terminalInfo.textContent = `${terminal.cols}×${terminal.rows}`;
                
                // Asegurar color de fondo
                $('.xterm-screen, .xterm-viewport').css('background-color', '#300A24');
            }
        }, 300);
    }
    
    // Eventos para manejar cambio de tamaño de ventana
    $(window).on('resize', function() {
        if (terminal && fitAddon) {
            fitAddon.fit();
            
            // Actualizar información de tamaño
            terminalInfo.textContent = `${terminal.cols}×${terminal.rows}`;
            
            // Asegurar color de fondo
            $('.xterm-screen, .xterm-viewport').css('background-color', '#300A24');
        }
    });
    
    // Asegurar que el color de fondo se mantiene
    setInterval(function() {
        if (terminal) {
            $('.xterm-screen, .xterm-viewport').css('background-color', '#300A24');
        }
    }, 2000);

    // Función para conectar al servidor SSH después de iniciar Reverb
    function connectToSSHServer(username, password = '') {
        updateConnectionStatus(false, 'Conectando...');
        terminal.write(`\r\n\x1B[1;34m● Conectando al servidor SSH como \x1B[1;36m${username}\x1B[0m usando autenticación por clave...\r\n`);
        
        $.ajax({
            url: '/api/terminal/connect',
            type: 'POST',
            data: {
                host: '{{ $host->ip_address }}',
                username: username,
                _token: '{{ csrf_token() }}'
            },
            timeout: 20000, // 20 segundos de timeout
            success: function(response) {
                if (response.success) {
                    isConnected = true;
                    sessionId = response.sessionId;
                    updateConnectionStatus(true, `Conectado: ${username}@{{ $host->hostname }}`);
                    terminal.write('\r\n\x1B[1;32m✓ Conexión establecida. Terminal listo.\x1B[0m\r\n');
                    terminal.write('\r\n\x1B[1;36m' + username + '@{{ $host->hostname }}:~$\x1B[0m ');
                    
                    // Actualizar prompt actual
                    currentPrompt = `${username}@{{ $host->hostname }}:~$ `;
                    
                    // Actualizar título de la terminal
                    updateTerminalTitle(username);
                    
                    // Configurar WebSocket para esta sesión si estamos usando WebSockets
                    if (usingWebsockets) {
                        setupWebSocketConnection(sessionId);
                    }
                    
                    // Activar botón
                    $('#connect-terminal-button').prop('disabled', false).html('<i class="fas fa-power-off"></i> Desconectar');
                    
                    // Ejecutar comando inicial para ir al directorio del usuario
                    executeCommand('cd ~');

                    // Verificar si WebSockets falló y mostrar instrucciones
                    setTimeout(function() {
                        if (window.echoConnectionFailed) {
                            showReverbInstructions();
                        }
                    }, 5000);
                } else {
                    updateConnectionStatus(false, 'Error de conexión');
                    terminal.write('\r\n\x1B[1;31m✗ Error: ' + response.message + '\x1B[0m\r\n');
                    $('#connect-terminal-button').prop('disabled', false).html('<i class="fas fa-terminal"></i> Conectar');
                }
            },
            error: function(xhr) {
                let message = 'Error de conexión';
                if (xhr.responseJSON && xhr.responseJSON.message) {
                    message = xhr.responseJSON.message;
                }
                updateConnectionStatus(false, 'Falló la conexión');
                terminal.write('\r\n\x1B[1;31m✗ Error: ' + message + '\x1B[0m\r\n');
                
                // Mostrar opción para reintentar
                terminal.write('\r\n\x1B[1;33m⚠ Presiona Enter para intentar nuevamente\x1B[0m\r\n');
                retryConnection = true;
                $('#connect-terminal-button').prop('disabled', false).html('<i class="fas fa-terminal"></i> Conectar');
            }
        });
    }

    // Función para procesar las respuestas WebSocket y cancelar timeouts
    function processWebSocketResponse(event) {
        // Cancelar timeout de respuesta si existe
        if (window.lastCommandTimeout) {
            clearTimeout(window.lastCommandTimeout);
            window.lastCommandTimeout = null;
        }
        
        console.log('WebSocket: Evento recibido', event);
        
        // Si es comando de limpiar terminal
        if (event.clear) {
            terminal.clear();
            return;
        }
        
        // Escribir la salida en el terminal
        if (event.output) {
            // Procesar salida para colorear
            let formattedOutput = formatOutput(event.output);
            terminal.write(formattedOutput);
        }
        
        // Actualizar el directorio actual si se proporciona
        if (event.currentDirectory) {
            // Obtener el nombre de usuario actual del prompt
            const currentUser = getCurrentUserFromPrompt();
            
            currentDirectory = event.currentDirectory;
            currentPrompt = `${currentUser}@{{ $host->hostname }}:${formatPath(currentDirectory)}$ `;
            updateTerminalTitle(currentUser);
        }
        
        // Si ha terminado el comando, mostrar el nuevo prompt
        terminal.write('\r\n' + currentPrompt);
        
        // Forzar scroll al fondo
        scrollToBottom();
    }

});
</script>
@endsection 